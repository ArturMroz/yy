// recursion

let fib = fun(n) {
    if n < 2 {
        yeet n;
    }
    yeet fib(n-1) + fib(n-2);
}

fib(20);
 
let fib2 = fun(n) {
    if n < 2 {
        n;
    } else {
        fib(n-1) + fib(n-2);
    }
}

fib2(20);

assert(fib(5) == fib2(5))
// assert accepts optional error message for more context
assert(fib(5) == fib2(5), "fibonaccis are different") 

let factorial = fun(n) { 
    if n == 0 { 1 } else { n * factorial(n-1) };
};

factorial(5);


// higher-order functions

let addThree     = fun(x) { yeet x + 3 };
let callTwoTimes = fun(x, func) { func(func(x)) }
callTwoTimes(3, addThree);


let add       = fun(a, b) { a + b };
let sub       = fun(a, b) { a - b };
let applyFunc = fun(a, b, func) { func(a, b) };

assert(applyFunc(2, 2, add) == 4); 
assert(applyFunc(10, 2, sub) == 8);

// closures 

let newAdder = fun(x) { fun(n) { x + n } };
let addTwo   = newAdder(2);
addTwo(2);

// built-ins & arrays

let map = fun(arr, f) {
    let iter = fun(arr, accumulated) {
        if (len(arr) == 0) {
            accumulated
        } else {
            iter(rest(arr), push(accumulated, f(first(arr))));
        }
    };
    iter(arr, []);
};

let a      = [1, 2, 3, 4];
let double = fun(x) { x * 2 };
yell(map(a, double)); // outputs [2, 4, 6 8]

let reduce = fun(arr, initial, f) {
    let iter = fun(arr, result) {
        if (len(arr) == 0) {
            result
        } else {
            iter(rest(arr), f(result, first(arr)));
        }
    };

    iter(arr, initial);
};

let sum = fun(arr) {
    reduce(arr, 0, fun(initial, el) { initial + el });
};

assert(sum([1, 2, 3, 4, 5]) == 15);