// FUNCTIONS/LAMBDAS

// anonymous functions (lambdas) are declared using '\'
// (if you squint hard enough, '\' looks kinda like lambda 'Î»')
// named functions are not supported

max := \x y {
    if x > y {
        yeet x // yeets the value and returns from the function
    } 
    yeet y
}

a := 3
b := 18
assert(max(a, b) == b)

// 'yeet' keyword can be omitted, last statement in a block is yeeted implicitly
max2 := \x y {
    if x > y {
        x 
    } else {
        y
    }
}

assert(max(a, b) == max2(a, b))

// and again, as a one liner
max3 := \x y { if x > y { x } else { y } }

assert(max2(a, b) == max3(a, b))


// RECURSION

fib := \n {
    if n < 2 {
        n 
    } else {
        fib(n-1) + fib(n-2)
    }
}

assert(fib(18) == 2584)
// assert() accepts optional error message for more context
assert(fib(20) == 6765, "fibonacci didn't quite work")

factorial := \n { 
    if n == 0 { 1 } else { n * factorial(n-1) }
}

assert(factorial(0) == 1)
assert(factorial(1) == 1)
assert(factorial(5) == 120)


// HIGHER-ORDER FUNCTIONS

addThree     := \x { x + 3 }
callTwoTimes := \x fn { fn(fn(x)) }
assert(callTwoTimes(3, addThree) == 9)

// parens and commas are optional
add     := \a b { a + b }
sub     := \a b { a - b }
applyFn := \fn a b { fn(a, b) }

assert(applyFn(add, 2, 2) == 4) 
assert(applyFn(sub, 10, 2) == 8)

// and the above could be written as such
add     := \(a, b) { a + b }
sub     := \(a, b) { a - b }
applyFn := \(fn, a, b) { fn(a, b) }

assert(applyFn(add, 2, 2) == 4) 
assert(applyFn(sub, 10, 2) == 8)


// CLOSURES

newAdder := \x { \n { x + n } }
addTwo   := newAdder(2)
assert(addTwo(5) == 7)


// BUILT-INS

// first(), rest(), and push() are built in and can be used to contruct functions like map(), reduce(), or filter()

map := \arr f {
    iter := \arr acc {
        if (len(arr) == 0) {
            acc
        } else {
            iter(rest(arr), push(acc, f(first(arr))))
        }
    }

    iter(arr, [])
}

a      := [1, 2, 3, 4]
double := \x { x * 2 }
assert(map(a, double) == [2, 4, 6, 8])
assert(map(a, \x { x * 3 }) == [3, 6, 9, 12])


reduce := \arr initial f {
    iter := \arr result {
        if (len(arr) == 0) {
            result
        } else {
            iter(rest(arr), f(result, first(arr)))
        }
    }

    iter(arr, initial)
}

sum := \arr {
    reduce(arr, 0, \initial el { initial + el })
}

assert(sum([1, 2, 3, 4, 5]) == 15)


filter := \arr f {
    iter := \arr acc {
        if (len(arr) == 0) {
            acc
        } else {
            if f(first(arr)) {
                iter(rest(arr), push(acc, first(arr)))
            } else {
                iter(rest(arr), acc)
            }
        }
    }

    iter(arr, [])
}

a    := [1, 2, 3, 4, 5, 6]
smol := \x { x < 4 }
assert(filter(a, smol) == [1, 2, 3])