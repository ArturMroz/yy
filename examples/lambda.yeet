// FUNCTIONS/LAMBDAS

max := \x y {
    if x > y {
        yeet x // yeets the value and returns from the function
    } else {
        yeet y
    }
}

a := 3;
b := 18;
c := max(a, b);
assert(b == c)
assert(max(12, 8) == 12)

// 'yeet' can be omitted, last statement in a block is returned implicitly
max2 := \x y {
    if x > y {
        x 
    } else {
        y
    }
}

assert(max(a, b) == max2(a, b))

// and again, as a one liner
max3 := \x y { if x > y { x } else { y } }

assert(max2(a, b) == max3(a, b))


// RECURSION

fib := \n {
    if n < 2 {
        n; 
    } else {
        fib(n-1) + fib(n-2);
    }
}

assert(fib(20) == 6765);
// assert() accepts optional error message for more context
assert(fib(20) == 6765, "fibonaccis are different");

factorial := \n { 
    if n == 0 { 1 } else { n * factorial(n-1) }
};

assert(factorial(0) == 1);
assert(factorial(1) == 1);
assert(factorial(5) == 120);


// HIGHER-ORDER FUNCTIONS

addThree     := \x { x + 3 };
callTwoTimes := \x, func { func(func(x)) }
assert(callTwoTimes(3, addThree) == 9)

// parens and commas are optional (for now)
add     := \a b { a + b };
sub     := \a b { a - b };
applyFn := \fn a b { fn(a, b) };

assert(applyFn(add, 2, 2) == 4); 
assert(applyFn(sub, 10, 2) == 8);

// and the above could be written as such (shadowing is allowed btw):
add     := \(a, b) { a + b };
sub     := \(a, b) { a - b };
applyFn := \(fn, a, b) { fn(a, b) };

assert(applyFn(add, 2, 2) == 4); 
assert(applyFn(sub, 10, 2) == 8);


// CLOSURES

newAdder := \x { fun(n) { x + n } };
addTwo   := newAdder(2);
assert(addTwo(5) == 7);


// BUILT-INS

// first(), rest(), & push() are builtin and can be used to contruct functions like map() or reduce()

map := \arr f {
    iter := \arr acc {
        if (len(arr) == 0) {
            acc
        } else {
            iter(rest(arr), push(acc, f(first(arr))));
        }
    };
    iter(arr, []);
};

a      := [1, 2, 3, 4];
double := \x { x * 2 };
assert(map(a, double) == [2, 4, 6, 8])
assert(map(a, \x { x * 3 }) == [3, 6, 9, 12])

reduce := \arr initial f {
    iter := \arr result {
        if (len(arr) == 0) {
            result
        } else {
            iter(rest(arr), f(result, first(arr)));
        }
    };

    iter(arr, initial);
};

sum := \arr {
    reduce(arr, 0, \initial, el { initial + el });
};

assert(sum([1, 2, 3, 4, 5]) == 15);